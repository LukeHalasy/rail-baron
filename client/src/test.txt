use gloo_events::EventListener;
use gloo_utils::format::JsValueSerdeExt;
use js_sys::{Array, Function};
use leaflet::{
    Circle, Control, LatLng, LatLngBounds, Map, Polygon, Polyline, Rectangle, TileLayer,
};
use serde::{Deserialize, Serialize};
use wasm_bindgen::{prelude::*, JsCast};
use web_sys::{console, window, Element, HtmlAnchorElement};

use store::{city::City, deed::Deed, sub_city::SubCity, *};

#[derive(Serialize, Deserialize)]
struct CircleOptions {
    radius: f32,
    color: String,
}

#[derive(Serialize, Deserialize)]
struct PolylineOptions {
    color: String,
}

#[derive(Serialize, Deserialize)]
struct ControlOptions {
    position: String,
}

#[derive(Serialize, Deserialize)]
struct ControlProps {
    options: ControlOptions,
}

// Called when the wasm module is instantiated
pub fn main() -> Result<(), JsValue> {
    // console::log_1(&"Running Leaflet example code in Rust.".into());

    let map = Map::new("map", &JsValue::NULL);
    map.setView(&LatLng::new(38.8951100, -77.0363700), 5.0);

    add_tile_layer(&map);
    for city in City::cities() {
        // L.circleMarker(city.latlng, {
        //   radius: 3,
        //   fillColor: 'black', // Change this to your desired fill color
        //   fillOpacity: 1,
        //   color: 'transparent' // Set the border color to transparent
        // }).addTo(map).bindPopup(city.name);

        Circle::new_with_options(
            &LatLng::new(
                city.coordinates().latitude(),
                city.coordinates().longitude(),
            ),
            &JsValue::from_serde(&CircleOptions {
                radius: 4000.0,
                color: "black".into(),
            })
            .expect("Unable to serialize circle options"),
        )
        .addTo(&map);
    }

    // for city in SubCity::sub_cities() {
    //     Circle::new_with_options(
    //         &LatLng::new(
    //             city.coordinates().latitude(),
    //             city.coordinates().longitude(),
    //         ),
    //         &JsValue::from_serde(&CircleOptions {
    //             radius: 4000.0,
    //             color: "red".into(),
    //         })
    //         .expect("Unable to serialize circle options"),
    //     )
    //     .addTo(&map);
    // }

    // let d = Deed::get_railroad_graph();
    // for (ci, route) in d.into_iter() {
    //     for r in route {
    //         let city_two = r.0;
    //         Polyline::new_with_options(
    //             [
    //                 LatLng::new(ci.coordinates().latitude(), ci.coordinates().longitude()),
    //                 LatLng::new(
    //                     city_two.coordinates().latitude(),
    //                     city_two.coordinates().longitude(),
    //                 ),
    //             ]
    //             .iter()
    //             .map(JsValue::from)
    //             .collect(),
    //             &JsValue::from_serde(&PolylineOptions {
    //                 color: "green".into(),
    //             })
    //             .expect("Unable to serialize polyline options"),
    //         )
    //         .addTo(&map);
    //     }
    // }

    // add_circle(&map);
    // add_circle_with_options(&map);
    // add_control(&map);

    Ok(())
}

fn add_tile_layer(map: &Map) {
    // TODO: Add attribution
    // TileLayer::new(
    //     "https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png",
    //     &JsValue::NULL,
    // )
    // .addTo(map);
    TileLayer::new(
        "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
        &JsValue::NULL,
    )
    .addTo(map);
}
